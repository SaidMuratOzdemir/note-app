import { Alert } from 'react-native';
import { Note } from '../types/Note';
import { SubNoteUtils, HIERARCHY_CONFIG, CanCreateResult } from '../utils/subNoteUtils';

export interface HierarchyWarningOptions {
  showDepthWarnings: boolean;
  showPerformanceWarnings: boolean;
  showCircularReferenceWarnings: boolean;
  autoShowWarnings: boolean;
}

export interface HierarchyWarningResult {
  canProceed: boolean;
  userConfirmed: boolean;
  warnings: string[];
  errors: string[];
}

/**
 * Comprehensive hierarchy warning system for multi-level sub-notes
 */
export class HierarchyWarningSystem {
  /**
   * Show depth warning when approaching or exceeding warning depth
   */
  static showDepthWarning(
    validation: CanCreateResult,
    parentNote: Note,
    onProceed: () => void,
    onCancel: () => void
  ): void {
    const currentDepth = validation.currentDepth;
    const newDepth = currentDepth + 1;
    
    let title = 'Derin Hiyerar≈üi Uyarƒ±sƒ±';
    let message = `Bu not ${newDepth}. seviyede olu≈üturulacak.`;
    
    if (newDepth >= HIERARCHY_CONFIG.MAX_DEPTH) {
      title = 'Maksimum Derinlik A≈üƒ±ldƒ±';
      message = `Maksimum ${HIERARCHY_CONFIG.MAX_DEPTH} seviye derinliƒüe ula≈ütƒ±nƒ±z. Bu not olu≈üturulamaz.`;
      
      Alert.alert(title, message, [
        { text: 'Tamam', style: 'cancel', onPress: onCancel }
      ]);
      return;
    }

    if (newDepth >= HIERARCHY_CONFIG.WARNING_DEPTH) {
      message += `\n\n√áok derin hiyerar≈üiler navigasyonu zorla≈ütƒ±rabilir.`;
      message += `\n\nMevcut yol: ${this.buildHierarchyPath(parentNote)}`;
      
      const buttons = [
        { text: 'Detaylarƒ± G√∂r', onPress: () => this.showHierarchyDetails(validation, parentNote) },
        { text: 'ƒ∞ptal', style: 'cancel' as const, onPress: onCancel },
        { text: 'Devam Et', onPress: onProceed }
      ];
      Alert.alert(title, message, buttons);
    } else {
      // No warning needed, proceed directly
      onProceed();
    }
  }

  /**
   * Show performance warning when approaching child limits
   */
  static showPerformanceWarning(
    validation: CanCreateResult,
    parentNote: Note,
    onProceed: () => void,
    onCancel: () => void
  ): void {
    const childrenCount = validation.childrenCount;
    
    if (childrenCount >= HIERARCHY_CONFIG.MAX_CHILDREN_PER_NODE) {
      Alert.alert(
        'Maksimum Alt Not Sayƒ±sƒ±',
        `Bu not altƒ±nda maksimum ${HIERARCHY_CONFIG.MAX_CHILDREN_PER_NODE} alt not bulunabilir. Yeni alt not olu≈üturulamaz.`,
        [{ text: 'Tamam', style: 'cancel', onPress: onCancel }]
      );
      return;
    }

    const warningThreshold = HIERARCHY_CONFIG.MAX_CHILDREN_PER_NODE * 0.8;
    if (childrenCount >= warningThreshold) {
      const message = `Bu not altƒ±nda ${childrenCount} alt not var.\n\n√ñneri: Alt notlarƒ± kategorilere ayƒ±rƒ±n.`;
      
      Alert.alert(
        'Performans Uyarƒ±sƒ±',
        message,
        [
          { text: 'Kategori Olu≈ütur', onPress: () => this.showCategoryCreationSuggestion(parentNote) },
          { text: 'ƒ∞ptal', style: 'cancel', onPress: onCancel },
          { text: 'Yine de Ekle', onPress: onProceed }
        ]
      );
    } else {
      // No warning needed, proceed directly
      onProceed();
    }
  }

  /**
   * Show circular reference prevention warning
   */
  static showCircularReferenceWarning(
    noteId: string,
    parentId: string,
    allNotes: Note[],
    onCancel: () => void
  ): void {
    const circularRefs = SubNoteUtils.findCircularReferences(allNotes);
    const affectedNote = allNotes.find(n => n.id === noteId);
    const parentNote = allNotes.find(n => n.id === parentId);
    
    const message = `Bu i≈ülem d√∂ng√ºsel referans olu≈üturacak.\n\n` +
      `"${affectedNote?.title || 'Ba≈ülƒ±ksƒ±z Not'}" notunu ` +
      `"${parentNote?.title || 'Ba≈ülƒ±ksƒ±z Not'}" notunun altƒ±na ta≈üƒ±yamazsƒ±nƒ±z.`;

    Alert.alert(
      'D√∂ng√ºsel Referans √ñnlendi',
      message,
      [
        { text: 'Detaylarƒ± G√∂r', onPress: () => this.showCircularReferenceDetails(circularRefs) },
        { text: 'Tamam', style: 'cancel', onPress: onCancel }
      ]
    );
  }

  /**
   * Comprehensive validation with all warnings
   */
  static async validateAndWarn(
    parentId: string,
    allNotes: Note[],
    options: HierarchyWarningOptions = {
      showDepthWarnings: true,
      showPerformanceWarnings: true,
      showCircularReferenceWarnings: true,
      autoShowWarnings: true
    }
  ): Promise<HierarchyWarningResult> {
    return new Promise((resolve) => {
      const validation = SubNoteUtils.canCreateSubNote(parentId, allNotes);
      const parentNote = allNotes.find(n => n.id === parentId);
      
      if (!parentNote) {
        resolve({
          canProceed: false,
          userConfirmed: false,
          warnings: [],
          errors: ['Parent note not found']
        });
        return;
      }

      // Check for hard errors first
      if (!validation.isValid) {
        const errors = [validation.reason || 'Unknown validation error'];
        
        if (options.autoShowWarnings) {
          Alert.alert(
            'Alt Not Olu≈üturulamƒ±yor',
            validation.reason || 'Bu not i√ßin alt not olu≈üturulamƒ±yor.',
            [{ text: 'Tamam', onPress: () => resolve({
              canProceed: false,
              userConfirmed: false,
              warnings: [],
              errors
            })}]
          );
        } else {
          resolve({
            canProceed: false,
            userConfirmed: false,
            warnings: [],
            errors
          });
        }
        return;
      }

      // Check for warnings
      const warnings = validation.warnings || [];
      
      if (warnings.length === 0 || !options.autoShowWarnings) {
        // No warnings or auto-warnings disabled
        resolve({
          canProceed: true,
          userConfirmed: true,
          warnings,
          errors: []
        });
        return;
      }

      // Show warnings dialog
      const message = warnings.join('\n\n') + '\n\nDevam etmek istiyor musunuz?';
      
      Alert.alert(
        'Hiyerar≈üi Uyarƒ±sƒ±',
        message,
        [
          { 
            text: 'Detaylarƒ± G√∂r',
            onPress: () => {
              this.showHierarchyDetails(validation, parentNote);
              resolve({
                canProceed: false,
                userConfirmed: false,
                warnings,
                errors: []
              });
            }
          },
          { 
            text: 'ƒ∞ptal',
            style: 'cancel',
            onPress: () => resolve({
              canProceed: false,
              userConfirmed: false,
              warnings,
              errors: []
            })
          },
          { 
            text: 'Devam Et',
            onPress: () => resolve({
              canProceed: true,
              userConfirmed: true,
              warnings,
              errors: []
            })
          }
        ]
      );
    });
  }

  /**
   * Show detailed hierarchy information
   */
  private static showHierarchyDetails(validation: CanCreateResult, parentNote: Note): void {
    const details = [
      `Mevcut Derinlik: ${validation.currentDepth}`,
      `Yeni Derinlik: ${validation.currentDepth + 1}`,
      `Maksimum Derinlik: ${validation.maxDepthAllowed}`,
      `Alt Not Sayƒ±sƒ±: ${validation.childrenCount}`,
      `Performans: ${validation.wouldExceedDepth ? 'Kritik' : validation.wouldExceedChildren ? 'Uyarƒ±' : 'ƒ∞yi'}`,
    ];

    if (validation.suggestions && validation.suggestions.length > 0) {
      details.push('', '√ñneriler:');
      details.push(...validation.suggestions.map(s => `‚Ä¢ ${s}`));
    }

    Alert.alert(
      'Hiyerar≈üi Detaylarƒ±',
      details.join('\n'),
      [{ text: 'Tamam' }]
    );
  }

  /**
   * Show circular reference details
   */
  private static showCircularReferenceDetails(circularRefs: any[]): void {
    const details = circularRefs.length > 0 
      ? `${circularRefs.length} d√∂ng√ºsel referans tespit edildi.`
      : 'D√∂ng√ºsel referans riski bulundu.';

    Alert.alert(
      'D√∂ng√ºsel Referans Detaylarƒ±',
      details,
      [{ text: 'Tamam' }]
    );
  }

  /**
   * Show category creation suggestion
   */
  private static showCategoryCreationSuggestion(parentNote: Note): void {
    const suggestions = [
      '1. Ana kategoriler olu≈üturun (√∂r: "Toplantƒ±lar", "G√∂revler")',
      '2. ƒ∞lgili alt notlarƒ± bu kategorilere ta≈üƒ±yƒ±n',
      '3. Yeni alt notlarƒ± uygun kategoriler altƒ±nda olu≈üturun'
    ];

    Alert.alert(
      'Kategori Olu≈üturma √ñnerisi',
      `"${parentNote.title || 'Bu not'}" i√ßin kategori d√ºzenleme √∂nerileri:\n\n${suggestions.join('\n\n')}`,
      [{ text: 'Anladƒ±m' }]
    );
  }

  /**
   * Build hierarchy path string for display
   */
  private static buildHierarchyPath(note: Note): string {
    // This would need access to allNotes to build the full path
    // For now, just return the note title
    return note.title || 'Ba≈ülƒ±ksƒ±z Not';
  }

  /**
   * Check hierarchy health and show issues if any
   */
  static checkHierarchyHealth(allNotes: Note[]): void {
    const health = SubNoteUtils.validateHierarchyHealth(allNotes);
    
    if (!health.isHealthy || health.warnings.length > 0) {
      const issues = [
        ...health.issues.map(issue => `‚ùå ${issue}`),
        ...health.warnings.map(warning => `‚ö†Ô∏è ${warning}`)
      ];

      const stats = [
        `üìä ƒ∞statistikler:`,
        `‚Ä¢ Toplam not: ${health.stats.totalNotes}`,
        `‚Ä¢ Ana not: ${health.stats.rootNotes}`,
        `‚Ä¢ Maksimum derinlik: ${health.stats.maxDepth}`,
        `‚Ä¢ Ortalama derinlik: ${health.stats.avgDepth}`,
      ];

      if (health.stats.circularReferences > 0) {
        stats.push(`‚Ä¢ D√∂ng√ºsel referans: ${health.stats.circularReferences}`);
      }

      const message = [...issues, '', ...stats].join('\n');

      Alert.alert(
        health.isHealthy ? 'Hiyerar≈üi Uyarƒ±larƒ±' : 'Hiyerar≈üi Sorunlarƒ±',
        message,
        [{ text: 'Tamam' }]
      );
    } else {
      Alert.alert(
        'Hiyerar≈üi Saƒülƒ±klƒ±',
        '‚úÖ Not hiyerar≈üiniz saƒülƒ±klƒ± durumda.',
        [{ text: 'Tamam' }]
      );
    }
  }
}

export default HierarchyWarningSystem;